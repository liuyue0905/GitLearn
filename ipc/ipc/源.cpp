/*
进程间通信：进程之间的沟通交流
进程间为什么要沟通交流？
在实际工作中往往会出现在一个系统中好几个进程协同工作，那么这些进程就需要沟通交流，完成协作，而由于进程的独立性， 进程间的沟通变得困难，复杂。因此就产生了各种进程间通信方式，来解决如何进行进程间通信的问题。
进程间通信的目的：
数据传输：一个进程需要将它的数据发送给另一个进程；
资源共享：多个进程间共享同样的资源；
通知事件：一个进程需要向另一个或一组进程发消息，通知它们发生了某种事件（如进程终止时要通知父进程）。
进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。
进程间通信方式：

管道
管道：传输资源。本质上是内核的一块缓冲区。（特性：半双工，单向通信）。 Linux一切皆文件，操作系统为管道提供操作的方法：文件操作

管道分为：匿名管道/命名管道
匿名管道
没有名字的管道（仅用于具有亲缘关系（父子，兄弟等）的进程间通信）。
创建匿名管道：pipe

#include <unistd.h>
int pipe(int pipefd[2]);
pipefd:用于接受匿名管道创建成功后返回的两个描述符，两个描述符用于对管道进行操作（文件io操作）
pipefd[0]:用于从管道读取数据；
pipefd[1]:用于向管道写入数据
返回值： 返回：0    失败： -1

匿名管道原理：以父子进程为例：创建一个子进程，子进程复制了父进程的描述符表，因此子进程也有描述符表，并且他们指向的是同一个管道，由于父子进程都能访问这个管道，就可以通信。
因为管道是半双工单向通信，因此在通信前要确定数据流向：即关闭父子进程各自一端不用的读写。如果一方是读数据就关闭写的描述符。


匿名管道特性：
1.只能用于具有亲缘关系的进程间通信；
2.管道是半双工单向通信；（两个文件描述符，用一个，另一个不用，不用的文件描述符就要close）
3.管道的生命周期随进程（打开管道的所有进程退出，管道释放）；
4.管道是面向字节流传输数据。（面向字节流：数据无规则，没有明显边界，收发数据比较灵活：对于用户态，可以一次性发送也可以分次发送，当然接受数据也如此；而面向数据报：数据有明显边界，数据只能整条接受 ）
5.内核会对管道操作进行同步与互斥；
临界资源： 大家都能访问到的共享资源
临界区： 对临界资源进行操作的代码
同步： 临界资源访问的可控时序性（一个操作完另一个才可以操作）
互斥： 对临界资源同一时间的唯一访问性（保护临界资源安全）
匿名管道读写规则：
1.管道无数据读取（read）： 如果描述符是默认的阻塞特性，读取将会阻塞挂起等待，直到管道有数据；
2.管道被写满（write）：如果描述符是默认的阻塞特性，写入操作会阻塞挂起等到，直到有数据被取走；如果描述符被设置为非阻塞特性，写入操作不具备条件，直接报错返回-1，错误码：EAGAIN。
3.如果所有管道写入端对应的文件描述符被关闭，则读取完管道中数据，然后read返回0；
4.如果所有管道读取端对应的文件描述符被关闭，则write操作会触发异常（因为没有人读数据），操作系统会给进程发送SIGPIPE,进程收到这个进程会退出；
5.当要写入的数据量不大于PIPE_BUF（512字节）时，linux将保证写入的原子性（操作不会被打断，一步完成）；
6.当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性

*/

//这是一个匿名管道实现：功能：从父进程写入数据，子进程读取数据
#include<stdio.h>
#include<unistd.h>
#include<string.h>
#include<errno.h>

int main()
{
	int fd[2];
	//管道需要创建在创建子进程前，这样才能复制
	if (pipe(fd)<0)
	{
		perror("pipe errno");
		return -1;
	}
	int pid = -1;
	pid = fork();//创建子进程，对于父进程会返回子进程id，子进程会返回0，创建失败会返回0
	if (pid<0)
	{
		perror("fork errno");
		return -1;
	}
	else if (pid == 0)
	{
		//子进程 读取数据-> fd[0]
		close(fd[1]);//fd[1]是向管道写入数据，子进程不用写入数据，需要关闭管道写入端
		char buff[1024] = { 0 };
		read(fd[0], buff, 1024);//如果管道没数据会等待，然后读取数据，默认阻塞等待直至有数据
		printf("buff:%s\n", buff);
		close(fd[0]);
	}
	else
	{
		//父进程 ：写入数据->fd[1]
		close(fd[0]); //fd[0]是读取数据，父进程不用读取数据，需要关闭管道读取端，由于父子进程相互独立，关闭一方描述符对另一方无影响   
		write(fd[1], "happy day", 10);
		close(fd[1]);
	}
	return 0;
}




