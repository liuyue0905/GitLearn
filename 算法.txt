//1.实现strcpy.    
char* MyStrCpy( char *pDest, const char *pSrc )    
{    
    if( nullptr == pDest || nullptr == pSrc )    
    {    
        return nullptr;    
    }    
    if( pDest == pSrc )    
    {    
        return pDest;    

    }    

    char *pIter = pDest;    //由于pDest的指针已经移动了所以要有个指针用来辅助
    while( ( *pIter++=*pSrc++ ) !='\0' );    
    return pDest;    
}

//2.实现strcat.链接字符    
char* MyStrCat( char *pDest, const char *pSrc )    
{    
    if( nullptr == pDest || nullptr == pSrc )    
    {    
        return nullptr;    
    }    
  
    char *pIter = pDest + strlen( pDest );    
    while( ( *pIter++=*pSrc++ ) != '\0' );    
    return pDest;    

}

//3.实现CString字符串类缺省四个方法    
class MyCString    
{    
public:    
  
    MyCString( char *pData = nullptr )    
    {    
        if( nullptr == pData )    
        {    
            mpData = new char[ 1 ];    
            assert( nullptr != mpData );    
            *mpData = '\0';    
        }    
        else    
        {    
            mpData = new char[ strlen( pData ) + 1 ];    
            assert( nullptr != mpData );    
            strcpy( mpData, pData );    
        }    
    }    
  
    MyCString( const MyCString &Other )    
    {    
        mpData = new char[ strlen( Other.mpData ) + 1 ];    
        assert( nullptr != mpData );    
        strcpy( mpData, Other.mpData );    
    }    
  
    ~MyCString()    
    {    
        if( nullptr != mpData )    
        {    
            delete [] mpData;    
            mpData = nullptr;    
        }    
    }    
  
    const MyCString& operator =( const MyCString &Other )    
    {    
        if( this == &Other )    
        {    
            return *this;    
        }    
        delete [] mpData;    
        mpData = new char[ strlen( Other.mpData ) + 1 ];    
        assert( nullptr != mpData );    
        strcpy( mpData, Other.mpData );    
        return *this;    
    }    
  
private:    
  
    char *mpData;    
};

//4.不使用第三个变量交换两个数的值    
void SwapA( int &A, int &B )    
{    
    if( A == B )    
    {    
        return;    
    }    
    A = A + B;    
    B = A - B;    
    A = A - B;    
}    
void SwapB( unsigned int &A, unsigned int &B )    //变量进行或运算
{    
    if( A == B )    
    {    
        return;    
    }  
    A = A ^ B;    
    B = A ^ B;    
    A = A ^ B;    
}

//5.实现一个将字符串逆序的方法    （轴对称两两置换）
char* MyInverted( char *pDest )    
{    
    assert( nullptr != pDest );    
    const int Len = strlen( pDest );    
    char T = 0;    
    for( int i = 0; i < Len / 2; ++i )    
    {    
        T = pDest[ i ];    
        pDest[ i ] = pDest[ Len - i - 1 ];    
        pDest[ Len - i -1 ] = T;    
    }    
    return pDest;    

}

//6.C语言中字符串转数字的方法是什么( atoi )，请实现它 （倒叙算差值，求累加值）
int Myatoi( const char *pString )    
{    
    assert( nullptr != pString );    
    const int Len = strlen( pString );    
    int Value = 0;    
    int Times = 1;    
    for( int i = Len -1; i >= 0; --i, Times *= 10 )    
    {    
        Value += ( pString[ i ] - '0' ) * Times;    
    }    
    return Value;    

}

//7.实现一个将字符串中所有字母转换为大写的方法 
char* MyUpper( char *pDest )    
{    
    assert( nullptr != pDest );    
    for( char *i = pDest; *i != '\0'; ++i )    
    {    
        if( *i < 'a' || *i > 'z' )    
        {    
            continue;    
        }    
        *i -= 'a' - 'A';    
    }    
    return pDest;    

}



//8.已知一个数组已经降序排序请用二分查字法找到其中的某个元素找到返回索引否则返回-1    
int BinarySearch( int *pArray, int Count, int Value )    
{    
    assert( nullptr != pArray );    
    int Left = 0;    
    int Right = Count -1;    
    int Mid = 0;    
    while( Left <= Right )    
    {    
        Mid = ( Left + Right ) / 2;    
        if( Value < pArray[ Mid ] )    
        {    
            Right = Mid - 1;    
        }    
        else if( Value > pArray[ Mid ] )    
        {    
            Left = Mid + 1;    
        }    
        else    
        {    
            return Mid;    
        }    
    }    
    return -1;    
}    

  //9.删除链表中值为Value的所有元素( [Head]->[node1]->[node2]->...[noden] )  

struct Node    
{    
    Node *mpNext;    
    int mData;    
};

void DeleteFromList( Node *pHead, int Value )  
{  
    Node *pPrev = pHead;  
    Node *pNext = pHead->mpNext;  
    while( nullptr != pNext )  
    {  
        if( pNext->mData != Value )  
        {  
            pPrev = pNext;  
            pNext = pNext->mpNext;  
        }  
        else  
        {  
            pPrev->mpNext = pNext->mpNext;  
            delete pNext;  
            pNext = pPrev->mpNext;  
        }  
    }  
}

//10.在链表Index位置插入新的值为Value的元素    
void InsertFromList( Node *pHead, int Index, int Value )    
{  
    Node *pIter = pHead;  
    for( int i = 0; i < Index && nullptr != pIter; ++i, pIter = pIter->mpNext );  
    assert( nullptr != pIter );  
    Node *pNew = new Node;  
    pNew->mData = Value;  
    pNew->mpNext = pIter->mpNext;  
    pIter->mpNext = pNew;  
}

//11.将链表逆序 （使用两个指针位置下移指向调换达到目的）
Node* InvertedFromList( Node *pHead )    
{    
    //A->B->C  
    Node *pPrev = pHead;            //A  
    Node *pNext = pHead->mpNext;        //B  
    Node *pNextNext = nullptr;        //C  
    while( nullptr != pNext )    
    {  
        pNextNext = pNext->mpNext;    //C = B->C  
        pNext->mpNext = pPrev;        //B->A  
  
        pPrev = pNext;                //A = B  
        pNext = pNextNext;            //B = C  
    }  
    pHead->mpNext = nullptr;//C->B->A->null  
    return pPrev;            //return C( new head )  

}



//12.判断X年X月X日是这年的第几天    
int GetDay( int Year, int Month, int Day )  
{    
    int MonthDays[ 13 ] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };    
  
    if( ( Year % 4 == 0 && Year % 100 != 0 ) || ( Year % 400 == 0 ) )    
    {    
        ++MonthDays[ 2 ];    
    }    
  
    int Days = 0;    
    for( int i = 1; i < Month; ++i )    
    {    
        Days += MonthDays[ i ];    
    }    
    Days += Day;    
  
    return Days;    

}

//14.递归求斐波拉契数列数列第N项  
int GetFibonacci2( int N )  
{  
    if( 1 == N || 2 == N )  
    {  
        return 1;  
    }  
    return GetFibonacci2( N - 1 ) + GetFibonacci2( N - 2 );  

}

//15.实现一个产生[N-M]区间数字的随机方法  
int GetRandomRange( int N, int M )  
{  
    if( N == M )  
    {  
        return N;  
    }  
    if( N > M )  
    {  
        N = N + M;  
        M = N - M;  
        N = N - M;  
    }  
    return N + ( rand() % ( M - N + 1 ) );  

}

//16.请用栈实现队列  
int QueuePop( std::stack< int > &StackA )  
{  
    std::stack< int > StackB;  
    while( false == StackA.empty() )  
    {  
        StackB.push( StackA.top() );  
        StackA.pop();  
    }  
  
    const int top = StackB.top();  
    StackB.pop();  
  
    while( false == StackB.empty() )  
    {  
        StackA.push( StackB.top() );  
        StackB.pop();  
    }  
    return top;  

}

//17.已知X班X成绩0-100分编写一个方法实现0-59打印不合格,60-69打印合格,70-79打印良好,80-100打印优秀  
//不能使用if,:?,switch  
void PrintScore( int Score )  
{  
    assert( Score >= 0 && Score <= 100 );  
    const char *pString[] =  
    {   
        "不合格",  
        "不合格",  
        "不合格",  
        "不合格",  
        "不合格",  
        "不合格",  
        "合格",  
        "良好",  
        "优秀",  
        "优秀",  
        "优秀",  
    };  
    printf( "%s\n", pString[ Score / 10 ] );  

}



//18.实现strncpy  
char *Mystrncpy( char *pDest, const char *pSrc, int Count )  
{  
    assert( NULL != pDest && NULL != pSrc );  
    if( pDest == pSrc )  
    {  
        return pDest;  
    }  
    if( Count <= 0 )  
    {  
        return pDest;  
    }  
    char *pStart = pDest;  
    while( ( Count-- ) > 0 && ( *pStart++=*pSrc++ ) );  
    *pStart = '\0';  
    return pDest;  

}



// 19.如何判断链表是否有环  
bool IsLoop( Node *pHead )  
{  
    //[H->A->B->C->A]  
    assert( NULL != pHead );  
    Node *pNext = pHead->mpNext;  
    Node *pNextNext = pHead->mpNext;  
    while( NULL != pNext && NULL != pNextNext->mpNext )  
    {  
        pNext = pNext->mpNext;//[ B、C、A ]  
        pNextNext = pNextNext->mpNext->mpNext;//[C、B、A]  
        if( pNext == pNextNext )  
        {  
            return true;  
        }  
    }  
    return false;  

}



//20.统计出一个字符串每种字母出现的次数要求时间复杂度为O(n)  
void CountLetter( const char *pSrc )  
{  
    int count[ 256 ] = {};  
    for( ; *pSrc !='\0'; ++pSrc )  
    {  
        const char &c = *pSrc;  
        if( ( c < 'A' || c > 'z') && ( c < 'a' || c > 'z' ) )  
        {  
            continue;  
        }  
        ++count[ c ];  
    }  
}